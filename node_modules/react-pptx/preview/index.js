'use strict';

var React = require('react');
var Color = require('color');
var ReactIs = require('react-is');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var Color__default = /*#__PURE__*/_interopDefaultLegacy(Color);
var ReactIs__default = /*#__PURE__*/_interopDefaultLegacy(ReactIs);

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

var POINTS_TO_INCHES = 1 / 72;
var layoutToInches = function (layout) {
    switch (layout) {
        case "16x10":
            return [10, 6.25];
        case "16x9":
            return [10, 5.625];
        case "4x3":
            return [10, 7.5];
        case "wide":
            return [13.3, 7.5];
    }
};
function isReactElementOrElementArray(
// eslint-disable-next-line @typescript-eslint/ban-types
arr) {
    return React__default['default'].isValidElement(arr);
}
function flattenChildren(children, depth, keys) {
    if (depth === void 0) { depth = 0; }
    if (keys === void 0) { keys = []; }
    return React__default['default'].Children.toArray(children).reduce(function (acc, node, nodeIndex) {
        if (ReactIs__default['default'].isFragment(node)) {
            acc.push.apply(acc, flattenChildren(node.props.children, depth + 1, keys.concat(node.key || nodeIndex)));
        }
        else {
            if (React__default['default'].isValidElement(node)) {
                acc.push(React__default['default'].cloneElement(node, {
                    key: keys.concat(String(node.key)).join("."),
                }));
            }
            else if (typeof node === "string" || typeof node === "number") {
                acc.push(node);
            }
        }
        return acc;
    }, []);
}

var TextLink = "text-link";
var TextFn = function () { return null; };
TextFn.prototype.isPptxTextElement = true;
TextFn.prototype.Link = TextLink;
var Text = Object.assign(TextFn, { Link: TextLink });
// We add a random symbol-ish to the prototype for use in isText
// For some reason a normal el.type == Text doesn't work here when
// the result is bundled
Text.prototype.isPptxTextElement = true;
var isText = function (el) {
    return el.type instanceof Function && el.type.prototype.isPptxTextElement;
};
var isImage = function (el) {
    return el.type === "image";
};
var isShape = function (el) {
    return el.type === "shape";
};

// Normalizer converts and normalizes JSX Presentation trees into internal nodes
var DEFAULT_FONT_SIZE = 18;
var DEFAULT_FONT_FACE = "Arial";
var normalizeHexColor = function (colorString) {
    return Color__default['default'](colorString).hex().substring(1).toUpperCase();
};
var normalizeHexOrComplexColor = function (colorString) {
    var clr = Color__default['default'](colorString);
    var hexColor = clr.hex().substring(1).toUpperCase();
    if (clr.alpha() === 1) {
        return hexColor;
    }
    else {
        return {
            type: "solid",
            color: hexColor,
            // Alpha is actually transparency (ie. 0=opaque, 1=fully transparent)
            alpha: 100 - Math.round(clr.alpha() * 100),
        };
    }
};
var normalizeText = function (t) {
    if (isReactElementOrElementArray(t)) {
        return flattenChildren(t).map(function (el) {
            if (React__default['default'].isValidElement(el)) {
                var props = el.props;
                var link = void 0;
                if (props.url) {
                    link = { url: props.url, tooltip: props.tooltip };
                }
                else if (props.slide) {
                    link = { slide: props.slide, tooltip: props.tooltip };
                }
                var children = props.children, style = props.style;
                return {
                    text: children,
                    link: link,
                    style: {
                        color: (style === null || style === void 0 ? void 0 : style.color) ? normalizeHexColor(style.color) : undefined,
                        fontFace: style === null || style === void 0 ? void 0 : style.fontFace,
                        fontSize: style === null || style === void 0 ? void 0 : style.fontSize,
                    },
                };
            }
            else {
                return {
                    text: el.toString(),
                    style: {},
                };
            }
        });
    }
    else if (Array.isArray(t)) {
        return t.reduce(function (prev, cur) { return prev.concat(normalizeText(cur)); }, []);
    }
    else if (typeof t === "number") {
        return [
            {
                text: t.toString(),
                style: {},
            },
        ];
    }
    else if (typeof t === "string") {
        return [{ text: t, style: {} }];
    }
    else {
        throw new TypeError("Invalid TextChild found; only strings/numbers/arrays of them are accepted");
    }
};
var PERCENTAGE_REGEXP = /^\d+%$/;
var normalizeCoordinate = function (x, _default) {
    if (typeof x === "string") {
        if (!PERCENTAGE_REGEXP.test(x)) {
            throw new TypeError("\"" + x + "\" is invalid position; string positions must be of format '[0-9]+%'");
        }
        return x;
    }
    else if (typeof x === "number") {
        return x;
    }
    return _default;
};
var normalizeSlideObject = function (node) {
    var _a, _b, _c, _d, _e, _f;
    if (!node.props.style) {
        throw new TypeError("A " + node.type + " object is missing style attribute");
    }
    var _g = node.props.style, x = _g.x, y = _g.y, w = _g.w, h = _g.h;
    x = normalizeCoordinate(x, 0);
    y = normalizeCoordinate(y, 0);
    w = normalizeCoordinate(w, 1);
    h = normalizeCoordinate(h, 1);
    if (isText(node)) {
        var style = node.props.style;
        return {
            kind: "text",
            text: node.props.children !== undefined
                ? normalizeText(node.props.children)
                : [],
            style: {
                x: x,
                y: y,
                w: w,
                h: h,
                color: style.color ? normalizeHexColor(style.color) : null,
                fontFace: (_a = style.fontFace) !== null && _a !== void 0 ? _a : DEFAULT_FONT_FACE,
                fontSize: (_b = style.fontSize) !== null && _b !== void 0 ? _b : DEFAULT_FONT_SIZE,
                align: (_c = style.align) !== null && _c !== void 0 ? _c : "left",
                verticalAlign: (_d = style.verticalAlign) !== null && _d !== void 0 ? _d : "middle",
            },
        };
    }
    else if (isImage(node)) {
        return {
            kind: "image",
            src: node.props.src,
            style: {
                x: x,
                y: y,
                w: w,
                h: h,
                sizing: (_e = node.props.style.sizing) !== null && _e !== void 0 ? _e : null,
            },
        };
    }
    else if (isShape(node)) {
        return {
            kind: "shape",
            type: node.props.type,
            text: node.props.children !== undefined
                ? normalizeText(node.props.children)
                : null,
            style: {
                x: x,
                y: y,
                w: w,
                h: h,
                backgroundColor: node.props.style.backgroundColor
                    ? normalizeHexOrComplexColor(node.props.style.backgroundColor)
                    : null,
                borderColor: node.props.style.borderColor
                    ? normalizeHexColor(node.props.style.borderColor)
                    : null,
                borderWidth: (_f = node.props.style.borderWidth) !== null && _f !== void 0 ? _f : null,
            },
        };
    }
    else {
        throw new Error("unknown slide object");
    }
};
var isPresent = function (x) {
    return x !== null;
};
var normalizeSlide = function (_a) {
    var _b, _c, _d, _e;
    var props = _a.props;
    var slide = {
        hidden: (_b = props.hidden) !== null && _b !== void 0 ? _b : false,
        backgroundColor: ((_c = props === null || props === void 0 ? void 0 : props.style) === null || _c === void 0 ? void 0 : _c.backgroundColor) ? normalizeHexColor(props.style.backgroundColor)
            : null,
        backgroundImage: (_e = (_d = props === null || props === void 0 ? void 0 : props.style) === null || _d === void 0 ? void 0 : _d.backgroundImage) !== null && _e !== void 0 ? _e : null,
        objects: [],
    };
    if (props.children) {
        slide.objects = flattenChildren(props.children)
            .map(normalizeSlideObject)
            .filter(isPresent);
    }
    return slide;
};
var normalizeJsx = function (_a) {
    var _b;
    var props = _a.props;
    var pres = {
        layout: (_b = props.layout) !== null && _b !== void 0 ? _b : "16x9",
        slides: [],
    };
    if (props.children) {
        pres.slides = flattenChildren(props.children).map(normalizeSlide);
    }
    return pres;
};

var normalizedColorToCSS = function (color) {
    if (typeof color === "string") {
        return "#" + color;
    }
    else {
        var r = parseInt(color.color.substring(0, 2), 16);
        var g = parseInt(color.color.substring(2, 4), 16);
        var b = parseInt(color.color.substring(4, 6), 16);
        return "rgba(" + r + ", " + g + ", " + b + ", " + (1 - color.alpha / 100) + ")";
    }
};
var SlideObjectShape = function (_a) {
    var shape = _a.shape;
    var baseStyle = {
        width: "100%",
        height: "100%",
        backgroundColor: shape.style.backgroundColor
            ? normalizedColorToCSS(shape.style.backgroundColor)
            : undefined,
    };
    if (shape.type === "rect") {
        return React.createElement("div", { style: baseStyle });
    }
    else if (shape.type === "ellipse") {
        return React.createElement("div", { style: __assign(__assign({}, baseStyle), { borderRadius: "100%" }) });
    }
    else {
        return (React.createElement("div", { style: __assign(__assign({}, baseStyle), { display: "flex", alignItems: "center", justifyContent: "center", overflow: "hidden" }) },
            React.createElement("div", { style: {
                    background: "rgba(0, 0, 0, 0) repeating-linear-gradient(45deg, yellow,  yellow 10px, black 10px, black 20px) repeat scroll 0% 0%",
                    padding: 5,
                    textAlign: "center",
                } },
                React.createElement("span", { style: { backgroundColor: "white", padding: 2 } },
                    "no preview for \"",
                    shape.type,
                    "\""))));
    }
};
var TextPreview = function (_a) {
    var parts = _a.parts, dimensions = _a.dimensions, slideWidth = _a.slideWidth;
    return (React.createElement("div", null, parts.map(function (part) {
        var _a, _b, _c, _d;
        var style = {
            fontSize: ((_a = part === null || part === void 0 ? void 0 : part.style) === null || _a === void 0 ? void 0 : _a.fontSize) ? ((part.style.fontSize * POINTS_TO_INCHES) / dimensions[0]) *
                slideWidth
                : undefined,
            color: ((_b = part === null || part === void 0 ? void 0 : part.style) === null || _b === void 0 ? void 0 : _b.color) ? normalizedColorToCSS(part.style.color)
                : undefined,
            fontFamily: (_d = (_c = part === null || part === void 0 ? void 0 : part.style) === null || _c === void 0 ? void 0 : _c.fontFace) !== null && _d !== void 0 ? _d : undefined,
        };
        if (part.link) {
            if (part.link.url) {
                return (React.createElement("a", { title: part.link.tooltip, href: part.link.url, style: style }, part.text));
            }
            else if (part.link.slide) {
                // Not supported yet
                return (React.createElement("a", { title: part.link.tooltip, style: __assign(__assign({}, style), { cursor: "not-allowed" }) }, part.text));
            }
        }
        else {
            return React.createElement("span", { style: style }, part.text);
        }
    })));
};
var constrainObjectFit = function (sizing) {
    var fit = sizing === null || sizing === void 0 ? void 0 : sizing.fit;
    if (fit === "contain" || fit === "cover") {
        return fit;
    }
    else {
        return undefined;
    }
};
var SlideObjectPreview = function (_a) {
    var object = _a.object, dimensions = _a.dimensions, slideWidth = _a.slideWidth, drawBoundingBoxes = _a.drawBoundingBoxes;
    var xPercentage = typeof object.style.x === "number"
        ? (object.style.x / dimensions[0]) * 100
        : parseInt(object.style.x, 10);
    var yPercentage = typeof object.style.y === "number"
        ? (object.style.y / dimensions[1]) * 100
        : parseInt(object.style.y, 10);
    var wPercentage = typeof object.style.w === "number"
        ? (object.style.w / dimensions[0]) * 100
        : parseInt(object.style.w, 10);
    var hPercentage = typeof object.style.h === "number"
        ? (object.style.h / dimensions[1]) * 100
        : parseInt(object.style.h, 10);
    return (React.createElement("div", { style: {
            position: "absolute",
            left: xPercentage + "%",
            top: yPercentage + "%",
            width: wPercentage + "%",
            height: hPercentage + "%",
            outline: drawBoundingBoxes ? "1px solid red" : undefined,
            boxSizing: "border-box",
        } }, object.kind === "text" ? (React.createElement("div", { style: {
            fontSize: ((object.style.fontSize * POINTS_TO_INCHES) / dimensions[0]) *
                slideWidth,
            color: object.style.color
                ? normalizedColorToCSS(object.style.color)
                : undefined,
            fontFamily: object.style.fontFace,
            display: "flex",
            alignItems: object.style.verticalAlign,
            textAlign: object.style.align,
            justifyContent: object.style.align,
        } },
        React.createElement(TextPreview, { parts: object.text, dimensions: dimensions, slideWidth: slideWidth }))) : object.kind === "image" ? (React.createElement("img", { src: object.src.kind === "data"
            ? "data:" + object.src[object.src.kind]
            : object.src[object.src.kind], style: {
            width: "100%",
            height: "100%",
            objectFit: constrainObjectFit(object.style.sizing),
        } })) : (React.createElement(SlideObjectShape, { shape: object }))));
};
var useResize = function (myRef) {
    var _a = React.useState(0), width = _a[0], setWidth = _a[1];
    var _b = React.useState(0), height = _b[0], setHeight = _b[1];
    React.useEffect(function () {
        var handleResize = function () {
            setWidth(myRef.current.offsetWidth);
            setHeight(myRef.current.offsetHeight);
        };
        handleResize();
        window.addEventListener("resize", handleResize);
        return function () {
            window.removeEventListener("resize", handleResize);
        };
    }, [myRef]);
    return { width: width, height: height };
};
var SlidePreview = function (_a) {
    var slide = _a.slide, dimensions = _a.dimensions, slideStyle = _a.slideStyle, drawBoundingBoxes = _a.drawBoundingBoxes;
    var ref = React.useRef(null);
    var width = useResize(ref).width;
    return (React.createElement("div", { ref: ref, style: __assign({ width: "100%", height: width / (dimensions[0] / dimensions[1]), backgroundColor: slide.backgroundColor
                ? "#" + slide.backgroundColor
                : "white", position: "relative" }, slideStyle) }, slide.objects.map(function (o, i) { return (React.createElement(SlideObjectPreview, { key: i, object: o, dimensions: dimensions, slideWidth: width, drawBoundingBoxes: drawBoundingBoxes })); })));
};
var Preview = function (props) {
    if (!props.children) {
        return null;
    }
    var presentationNode = React.Children.only(props.children);
    try {
        var normalized_1 = normalizeJsx(presentationNode);
        return (React.createElement("div", { style: {
                width: "100%",
            } }, normalized_1.slides.map(function (slide, i) { return (React.createElement(SlidePreview, { key: i, slide: slide, dimensions: layoutToInches(normalized_1.layout), slideStyle: props.slideStyle, drawBoundingBoxes: !!props.drawBoundingBoxes })); })));
    }
    catch (e) {
        // eslint-disable-next-line no-console
        console.warn(e);
        return (React.createElement("div", { style: {
                width: "100%",
                color: "orange",
            } },
            "invalid JSX: ",
            e.toString()));
    }
};

module.exports = Preview;
