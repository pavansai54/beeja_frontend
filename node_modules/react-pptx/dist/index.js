'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var pptxgen = require('pptxgenjs');
var fetch = require('cross-fetch');
var Color = require('color');
var React = require('react');
var ReactIs = require('react-is');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var pptxgen__default = /*#__PURE__*/_interopDefaultLegacy(pptxgen);
var fetch__default = /*#__PURE__*/_interopDefaultLegacy(fetch);
var Color__default = /*#__PURE__*/_interopDefaultLegacy(Color);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);
var ReactIs__default = /*#__PURE__*/_interopDefaultLegacy(ReactIs);

var TextLink = "text-link";
var isTextLink = function (el) {
    return el.type === "text-link";
};
var TextFn = function () { return null; };
TextFn.prototype.isPptxTextElement = true;
TextFn.prototype.Link = TextLink;
var Text = Object.assign(TextFn, { Link: TextLink });
// We add a random symbol-ish to the prototype for use in isText
// For some reason a normal el.type == Text doesn't work here when
// the result is bundled
Text.prototype.isPptxTextElement = true;
var isText = function (el) {
    return el.type instanceof Function && el.type.prototype.isPptxTextElement;
};
var Image = "image";
var isImage = function (el) {
    return el.type === "image";
};
var Shape = "shape";
var isShape = function (el) {
    return el.type === "shape";
};
var Slide = "slide";
var Presentation = "presentation";

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function isReactElementOrElementArray(
// eslint-disable-next-line @typescript-eslint/ban-types
arr) {
    return React__default['default'].isValidElement(arr);
}
function flattenChildren(children, depth, keys) {
    if (depth === void 0) { depth = 0; }
    if (keys === void 0) { keys = []; }
    return React__default['default'].Children.toArray(children).reduce(function (acc, node, nodeIndex) {
        if (ReactIs__default['default'].isFragment(node)) {
            acc.push.apply(acc, flattenChildren(node.props.children, depth + 1, keys.concat(node.key || nodeIndex)));
        }
        else {
            if (React__default['default'].isValidElement(node)) {
                acc.push(React__default['default'].cloneElement(node, {
                    key: keys.concat(String(node.key)).join("."),
                }));
            }
            else if (typeof node === "string" || typeof node === "number") {
                acc.push(node);
            }
        }
        return acc;
    }, []);
}

// Normalizer converts and normalizes JSX Presentation trees into internal nodes
var DEFAULT_FONT_SIZE = 18;
var DEFAULT_FONT_FACE = "Arial";
var normalizeHexColor = function (colorString) {
    return Color__default['default'](colorString).hex().substring(1).toUpperCase();
};
var normalizeHexOrComplexColor = function (colorString) {
    var clr = Color__default['default'](colorString);
    var hexColor = clr.hex().substring(1).toUpperCase();
    if (clr.alpha() === 1) {
        return hexColor;
    }
    else {
        return {
            type: "solid",
            color: hexColor,
            // Alpha is actually transparency (ie. 0=opaque, 1=fully transparent)
            alpha: 100 - Math.round(clr.alpha() * 100),
        };
    }
};
var normalizeText = function (t) {
    if (isReactElementOrElementArray(t)) {
        return flattenChildren(t).map(function (el) {
            if (React__default['default'].isValidElement(el)) {
                var props = el.props;
                var link = void 0;
                if (props.url) {
                    link = { url: props.url, tooltip: props.tooltip };
                }
                else if (props.slide) {
                    link = { slide: props.slide, tooltip: props.tooltip };
                }
                var children = props.children, style = props.style;
                return {
                    text: children,
                    link: link,
                    style: {
                        color: (style === null || style === void 0 ? void 0 : style.color) ? normalizeHexColor(style.color) : undefined,
                        fontFace: style === null || style === void 0 ? void 0 : style.fontFace,
                        fontSize: style === null || style === void 0 ? void 0 : style.fontSize,
                    },
                };
            }
            else {
                return {
                    text: el.toString(),
                    style: {},
                };
            }
        });
    }
    else if (Array.isArray(t)) {
        return t.reduce(function (prev, cur) { return prev.concat(normalizeText(cur)); }, []);
    }
    else if (typeof t === "number") {
        return [
            {
                text: t.toString(),
                style: {},
            },
        ];
    }
    else if (typeof t === "string") {
        return [{ text: t, style: {} }];
    }
    else {
        throw new TypeError("Invalid TextChild found; only strings/numbers/arrays of them are accepted");
    }
};
var PERCENTAGE_REGEXP = /^\d+%$/;
var normalizeCoordinate = function (x, _default) {
    if (typeof x === "string") {
        if (!PERCENTAGE_REGEXP.test(x)) {
            throw new TypeError("\"" + x + "\" is invalid position; string positions must be of format '[0-9]+%'");
        }
        return x;
    }
    else if (typeof x === "number") {
        return x;
    }
    return _default;
};
var normalizeSlideObject = function (node) {
    var _a, _b, _c, _d, _e, _f;
    if (!node.props.style) {
        throw new TypeError("A " + node.type + " object is missing style attribute");
    }
    var _g = node.props.style, x = _g.x, y = _g.y, w = _g.w, h = _g.h;
    x = normalizeCoordinate(x, 0);
    y = normalizeCoordinate(y, 0);
    w = normalizeCoordinate(w, 1);
    h = normalizeCoordinate(h, 1);
    if (isText(node)) {
        var style = node.props.style;
        return {
            kind: "text",
            text: node.props.children !== undefined
                ? normalizeText(node.props.children)
                : [],
            style: {
                x: x,
                y: y,
                w: w,
                h: h,
                color: style.color ? normalizeHexColor(style.color) : null,
                fontFace: (_a = style.fontFace) !== null && _a !== void 0 ? _a : DEFAULT_FONT_FACE,
                fontSize: (_b = style.fontSize) !== null && _b !== void 0 ? _b : DEFAULT_FONT_SIZE,
                align: (_c = style.align) !== null && _c !== void 0 ? _c : "left",
                verticalAlign: (_d = style.verticalAlign) !== null && _d !== void 0 ? _d : "middle",
            },
        };
    }
    else if (isImage(node)) {
        return {
            kind: "image",
            src: node.props.src,
            style: {
                x: x,
                y: y,
                w: w,
                h: h,
                sizing: (_e = node.props.style.sizing) !== null && _e !== void 0 ? _e : null,
            },
        };
    }
    else if (isShape(node)) {
        return {
            kind: "shape",
            type: node.props.type,
            text: node.props.children !== undefined
                ? normalizeText(node.props.children)
                : null,
            style: {
                x: x,
                y: y,
                w: w,
                h: h,
                backgroundColor: node.props.style.backgroundColor
                    ? normalizeHexOrComplexColor(node.props.style.backgroundColor)
                    : null,
                borderColor: node.props.style.borderColor
                    ? normalizeHexColor(node.props.style.borderColor)
                    : null,
                borderWidth: (_f = node.props.style.borderWidth) !== null && _f !== void 0 ? _f : null,
            },
        };
    }
    else {
        throw new Error("unknown slide object");
    }
};
var isPresent = function (x) {
    return x !== null;
};
var normalizeSlide = function (_a) {
    var _b, _c, _d, _e;
    var props = _a.props;
    var slide = {
        hidden: (_b = props.hidden) !== null && _b !== void 0 ? _b : false,
        backgroundColor: ((_c = props === null || props === void 0 ? void 0 : props.style) === null || _c === void 0 ? void 0 : _c.backgroundColor) ? normalizeHexColor(props.style.backgroundColor)
            : null,
        backgroundImage: (_e = (_d = props === null || props === void 0 ? void 0 : props.style) === null || _d === void 0 ? void 0 : _d.backgroundImage) !== null && _e !== void 0 ? _e : null,
        objects: [],
    };
    if (props.children) {
        slide.objects = flattenChildren(props.children)
            .map(normalizeSlideObject)
            .filter(isPresent);
    }
    return slide;
};
var normalizeJsx = function (_a) {
    var _b;
    var props = _a.props;
    var pres = {
        layout: (_b = props.layout) !== null && _b !== void 0 ? _b : "16x9",
        slides: [],
    };
    if (props.children) {
        pres.slides = flattenChildren(props.children).map(normalizeSlide);
    }
    return pres;
};

// Renderer renders normalized nodes into pptxgenjs presentations
var renderTextParts = function (parts) {
    return parts.map(function (part) {
        var _a, _b, _c, _d;
        return {
            text: part.text,
            options: {
                hyperlink: part.link,
                color: (_b = (_a = part === null || part === void 0 ? void 0 : part.style) === null || _a === void 0 ? void 0 : _a.color) !== null && _b !== void 0 ? _b : undefined,
                fontFace: (_c = part === null || part === void 0 ? void 0 : part.style) === null || _c === void 0 ? void 0 : _c.fontFace,
                fontSize: (_d = part === null || part === void 0 ? void 0 : part.style) === null || _d === void 0 ? void 0 : _d.fontSize,
            },
        };
    });
};
var renderSlideObject = function (pres, slide, object) { return __awaiter(void 0, void 0, void 0, function () {
    var _a, x, y, w, h, style, data, req, contentType, buffer, blob, reader_1, sizing, imageWidth, imageHeight, style, shapeType, backgroundColor;
    var _b, _c, _d, _e, _f, _g, _h, _j;
    return __generator(this, function (_k) {
        switch (_k.label) {
            case 0:
                _a = object.style, x = _a.x, y = _a.y, w = _a.w, h = _a.h;
                if (!(object.kind === "text")) return [3 /*break*/, 1];
                style = object.style;
                slide.addText(renderTextParts(object.text), {
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    color: (_b = style.color) !== null && _b !== void 0 ? _b : undefined,
                    fontFace: style.fontFace,
                    fontSize: style.fontSize,
                    align: style.align,
                    valign: style.verticalAlign,
                });
                return [3 /*break*/, 10];
            case 1:
                if (!(object.kind === "image")) return [3 /*break*/, 9];
                data = "";
                if (!(object.src.kind === "data")) return [3 /*break*/, 2];
                data = "data:" + object.src[object.src.kind];
                return [3 /*break*/, 8];
            case 2: return [4 /*yield*/, fetch__default['default'](object.src[object.src.kind])];
            case 3:
                req = _k.sent();
                if (!("buffer" in req)) return [3 /*break*/, 5];
                contentType = req.headers.raw()["content-type"][0];
                return [4 /*yield*/, req.buffer()];
            case 4:
                buffer = _k.sent();
                data = "data:" + contentType + ";base64," + buffer.toString("base64");
                return [3 /*break*/, 8];
            case 5: return [4 /*yield*/, req.blob()];
            case 6:
                blob = _k.sent();
                reader_1 = new FileReader();
                reader_1.readAsDataURL(blob);
                return [4 /*yield*/, new Promise(function (resolve) {
                        reader_1.onloadend = function () {
                            resolve(reader_1.result);
                        };
                    })];
            case 7:
                data = _k.sent();
                _k.label = 8;
            case 8:
                sizing = void 0;
                if (object.style.sizing && object.style.sizing.fit) {
                    imageWidth = (_c = object.style.sizing.imageWidth) !== null && _c !== void 0 ? _c : (typeof w === "number" ? w : parseInt(w, 10));
                    imageHeight = (_d = object.style.sizing.imageHeight) !== null && _d !== void 0 ? _d : (typeof h === "number" ? h : parseInt(h, 10));
                    if (isNaN(imageWidth) || isNaN(imageHeight)) {
                        throw new TypeError("when using sizing.fit, width and height must be specified numerically, either in style itself or in sizing.width/height!");
                    }
                    sizing = { type: object.style.sizing.fit, w: imageWidth, h: imageHeight };
                }
                slide.addImage({
                    data: data,
                    x: x,
                    y: y,
                    w: w,
                    h: h,
                    sizing: object.style.sizing ? sizing : undefined,
                });
                return [3 /*break*/, 10];
            case 9:
                if (object.kind === "shape") {
                    style = object.style;
                    shapeType = pres.ShapeType[object.type];
                    backgroundColor = typeof style.backgroundColor === "string"
                        ? { color: style.backgroundColor }
                        : (_e = style.backgroundColor) !== null && _e !== void 0 ? _e : undefined;
                    if (object.text) {
                        slide.addText(renderTextParts(object.text), {
                            shape: shapeType,
                            x: x,
                            y: y,
                            w: w,
                            h: h,
                            fill: backgroundColor,
                            line: {
                                size: (_f = style.borderWidth) !== null && _f !== void 0 ? _f : undefined,
                                color: (_g = style.borderColor) !== null && _g !== void 0 ? _g : undefined,
                            },
                        });
                    }
                    else {
                        slide.addShape(shapeType, {
                            x: x,
                            y: y,
                            w: w,
                            h: h,
                            fill: backgroundColor,
                            line: {
                                size: (_h = style.borderWidth) !== null && _h !== void 0 ? _h : undefined,
                                color: (_j = style.borderColor) !== null && _j !== void 0 ? _j : undefined,
                            },
                        });
                    }
                }
                _k.label = 10;
            case 10: return [2 /*return*/];
        }
    });
}); };
var renderSlide = function (pres, slide, node) { return __awaiter(void 0, void 0, void 0, function () {
    var _a;
    return __generator(this, function (_b) {
        slide.hidden = node.hidden;
        if (node.backgroundColor)
            slide.background = { fill: node.backgroundColor };
        if (node.backgroundImage) {
            slide.background = (_a = {},
                _a[node.backgroundImage.kind] = node.backgroundImage[node.backgroundImage.kind],
                _a);
        }
        return [2 /*return*/, Promise.all(node.objects.map(function (object) { return renderSlideObject(pres, slide, object); }))];
    });
}); };
var render = function (node, opts) { return __awaiter(void 0, void 0, void 0, function () {
    var normalized, pres, layout;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                normalized = normalizeJsx(node);
                pres = new pptxgen__default['default']();
                layout = "LAYOUT_16x9";
                if (normalized.layout === "16x10") {
                    layout = "LAYOUT_16x10";
                }
                else if (normalized.layout === "4x3") {
                    layout = "LAYOUT_4x3";
                }
                else if (normalized.layout === "wide") {
                    layout = "LAYOUT_WIDE";
                }
                pres.layout = layout;
                return [4 /*yield*/, Promise.all(normalized.slides.map(function (slideNode) {
                        var slide = pres.addSlide();
                        return renderSlide(pres, slide, slideNode);
                    }))];
            case 1:
                _b.sent();
                return [2 /*return*/, pres.write((_a = opts === null || opts === void 0 ? void 0 : opts.outputType) !== null && _a !== void 0 ? _a : "nodebuffer")];
        }
    });
}); };

exports.Image = Image;
exports.Presentation = Presentation;
exports.Shape = Shape;
exports.Slide = Slide;
exports.Text = Text;
exports.isImage = isImage;
exports.isShape = isShape;
exports.isText = isText;
exports.isTextLink = isTextLink;
exports.normalizeJsx = normalizeJsx;
exports.render = render;
